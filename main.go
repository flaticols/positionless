package main

import (
	"fmt"
	"go/ast"
	"go/types"
	"os"
	"strings"

	"golang.org/x/tools/go/analysis"
	"golang.org/x/tools/go/analysis/singlechecker"
)

var includeGenerated bool

var Analyzer = &analysis.Analyzer{
	Name: "positionless",
	Doc:  "reports positional struct literal initialization",
	Run:  run,
}

func init() {
	Analyzer.Flags.BoolVar(&includeGenerated, "generated", false,
		"include generated files in analysis")
}

func run(pass *analysis.Pass) (any, error) {
	if !includeGenerated {
		for _, file := range pass.Files {
			if isGeneratedFile(file) {
				continue
			}
			analyzeFile(pass, file)
		}
	} else {
		for _, file := range pass.Files {
			analyzeFile(pass, file)
		}
	}

	return nil, nil
}

func isGeneratedFile(file *ast.File) bool {
	for _, comment := range file.Comments {
		for _, c := range comment.List {
			text := strings.ToLower(c.Text)
			if strings.Contains(text, "code generated") ||
				strings.Contains(text, "do not edit") ||
				strings.Contains(text, "autogenerated") {
				return true
			}
		}
	}
	return false
}

func analyzeFile(pass *analysis.Pass, file *ast.File) {
	ast.Inspect(file, func(n ast.Node) bool {
		if cl, ok := n.(*ast.CompositeLit); ok {
			checkCompositeLit(pass, cl)
		}
		return true
	})
}

func checkCompositeLit(pass *analysis.Pass, cl *ast.CompositeLit) {
	if !isPositionalStruct(cl) {
		return
	}

	structType := getStructType(pass, cl)
	if structType == nil {
		return
	}

	if len(cl.Elts) > structType.NumFields() {
		return
	}

	fix := createNamedFieldsFix(pass, cl, structType)
	if fix == nil {
		return
	}

	pass.Report(analysis.Diagnostic{
		Pos:            cl.Pos(),
		End:            cl.End(),
		Message:        "positional struct literal initialization is fragile",
		SuggestedFixes: []analysis.SuggestedFix{*fix},
	})
}

func isPositionalStruct(cl *ast.CompositeLit) bool {
	if len(cl.Elts) == 0 {
		return false
	}

	for _, elt := range cl.Elts {
		if _, ok := elt.(*ast.KeyValueExpr); ok {
			return false
		}
	}

	return true
}

func getStructType(pass *analysis.Pass, cl *ast.CompositeLit) *types.Struct {
	tv, ok := pass.TypesInfo.Types[cl.Type]
	if !ok {
		return nil
	}

	typ := tv.Type
	if ptr, ok := typ.(*types.Pointer); ok {
		typ = ptr.Elem()
	}

	structType, ok := typ.Underlying().(*types.Struct)
	if !ok {
		return nil
	}

	return structType
}

func createNamedFieldsFix(pass *analysis.Pass, cl *ast.CompositeLit,
	structType *types.Struct) *analysis.SuggestedFix {

	var newText strings.Builder

	_ = pass.Fset.Position(cl.Lbrace)
	newText.WriteString("{\n")

	for i, elt := range cl.Elts {
		if i >= structType.NumFields() {
			return nil
		}

		field := structType.Field(i)
		if !field.Exported() {
			return nil
		}

		eltStart := pass.Fset.Position(elt.Pos())
		eltEnd := pass.Fset.Position(elt.End())

		if eltStart.Filename != eltEnd.Filename {
			return nil
		}

		src, err := os.ReadFile(eltStart.Filename)
		if err != nil {
			return nil
		}

		eltText := string(src[eltStart.Offset:eltEnd.Offset])

		newText.WriteString(fmt.Sprintf("\t%s: %s,\n", field.Name(), eltText))
	}

	newText.WriteString("}")

	return &analysis.SuggestedFix{
		Message: "convert to named field initialization",
		TextEdits: []analysis.TextEdit{
			{
				Pos:     cl.Lbrace,
				End:     cl.Rbrace + 1,
				NewText: []byte(newText.String()),
			},
		},
	}
}

func main() {
	singlechecker.Main(Analyzer)
}
