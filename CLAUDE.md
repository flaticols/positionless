# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

positionless is a Go static analyzer that detects positional struct literal initialization and suggests converting them to named field initialization. It's built using the `golang.org/x/tools/go/analysis` framework.

## Commands

<build_and_test>
```bash
# Build
go build -v ./...

# Run tests
go test -v ./...

# Install locally
go install .

# Use as standalone tool
positionless ./...
positionless -fix ./...           # Auto-fix issues
positionless -generated ./...     # Include generated files
positionless -unexported ./...    # Include structs with unexported fields
positionless -internal ./...      # Auto-allow unexported in internal/ packages
positionless -ignore=Pattern ./...  # Skip matching struct types
positionless -output=json ./...   # JSON output (golangci-lint format, to stderr)

# Use with go vet
go vet -vettool=$(which positionless) ./...
go vet -vettool=$(which positionless) -fix ./...
```
</build_and_test>

## Architecture

<core_components>
**Single-file analyzer** (`main.go`) - The entire analyzer logic is in one file:

1. **Entry point**: `singlechecker.Main(Analyzer)` - standard analysis framework pattern
2. **Analyzer instance**: Defines name, doc, run function, and `-generated` flag
3. **Analysis flow**:
   - `run()` → iterates AST files, skips generated files by default
   - `isGeneratedFile()` → checks comments for "code generated", "do not edit", "autogenerated"
   - `analyzeFile()` → uses `ast.Inspect` to find all `*ast.CompositeLit` nodes
   - `checkCompositeLit()` → validates struct, checks ignore patterns, reports diagnostics
   - `isPositionalStruct()` → returns true if no `*ast.KeyValueExpr` elements exist
   - `getStructType()` → extracts `*types.Struct` from type info, handles pointers
   - `createNamedFieldsFix()` → builds replacement text with named fields
   - `isInternalPackage()` → checks if file path contains `/internal/`
   - `shouldAllowUnexported()` → determines if unexported fields should be processed
   - `matchesIgnorePattern()` → checks struct type against ignore patterns
</core_components>

<key_code_points>
**Detection logic** (`main.go:216-228`): A composite literal is positional if it has elements but none are `KeyValueExpr`.

**Fix generation** (`main.go:249-302`): Reads source file bytes, extracts original element text by offset, reconstructs with field names. Returns both fix and unexported field status.

**Type resolution** (`main.go:231-247`): Uses `pass.TypesInfo.Types` to get struct type, unwraps pointers via `typ.(*types.Pointer).Elem()`.

**Internal detection** (`main.go:94-103`): Checks if file path contains `/internal/` for auto-allowing unexported fields.

**Ignore patterns** (`main.go:105-124`): Supports glob patterns and substring matching for struct type names.
</key_code_points>

## Test Structure

<testing>
Tests use `golang.org/x/tools/go/analysis/analysistest` framework:

```bash
testdata/src/
├── basic/          # Simple positional structs
├── nested/         # Nested struct initialization
├── pointer/        # Pointer receivers, recursive structs
├── edge/           # Empty structs, unexported fields, embedded types
├── generated/      # Generated file detection
├── internal/config # Internal package detection tests
├── unexported/     # Tests for -unexported flag
└── ignore/         # Tests for -ignore flag
```

Test annotations use `// want "message"` comments to assert expected diagnostics:
```go
p := Person{"John", 30}  // want "positional struct literal initialization is fragile"
```

Run specific test packages by editing `analysistest.Run()` call in `main_test.go`.
</testing>

## Limitations

<limitations>
- **Unexported fields**: By default, reports but can't fix structs with unexported fields. Use `-unexported` or `-internal` to enable fixes.
- **Cross-file elements**: Skips if element spans multiple files
- **Field count mismatch**: Aborts if element count exceeds struct field count
- **Generated file patterns**: Only detects specific keywords in comments - custom patterns may be missed
- **Exit code 3**: Used for "findings exist" status in CI - not a failure code
- **JSON output**: Use `-output=json` for JSON lines to stderr. Normal text output still goes to stdout.
</limitations>

## Verification

<verification>
To verify implementation changes:

```bash
# 1. Run full test suite
go test -v ./...

# 2. Test on real code
positionless ./...                    # Check current project
positionless -fix /tmp/testdir/...    # Test fix generation

# 3. Verify generated file handling
positionless testdata/src/generated/  # Should find nothing
positionless -generated testdata/src/generated/  # Should find issues

# 4. Test unexported field handling
positionless testdata/src/edge/              # Reports MixedExport without fix
positionless -unexported testdata/src/edge/  # Reports MixedExport WITH fix

# 5. Test internal package detection
positionless -internal testdata/src/internal/...  # Should fix unexported in internal/

# 6. Test ignore patterns
positionless -ignore="MixedExport" testdata/src/edge/  # Should skip MixedExport

# 7. Test JSON output
positionless -output=json testdata/src/basic/ 2>&1  # JSON to stderr

# 8. Check fix output manually
positionless -fix ./testdata/src/basic/ 2>&1  # Inspect applied fixes
git diff                                       # Review changes
git checkout -- testdata/                      # Reset test files
```
</verification>

## GitHub Action

The project provides a GitHub Action (`action.yml`) that downloads the binary and runs analysis. Exit code 3 signals findings to fail CI pipelines.
